# Soft Navigation JavaScript Review

## Общее впечатление
- Скрипт `wwwroot/js/soft-navigation.js` реализует "мягкую" навигацию: перехватывает клики/submit, подменяет содержимое `#app`, управляет анимациями и состояниями загрузки.
- Код оформлен как один большой самовызывающийся модуль. Это облегчает подключение, но усложняет сопровождение и повторное использование отдельных частей.

## Сильные стороны
- Есть проверки на поддержку API (`matchMedia`, `animate`, `fetch`) и fallback-ветки для старых браузеров.
- Перед запуском новой анимации вызывается `cancelAppAnimation`, что защищает от гонок и "залипаний" переходов.【F:wwwroot/js/soft-navigation.js†L16-L88】
- Обработчики кликов/submit ограничены контейнером `data-soft-root`, поэтому сторонний DOM не затрагивается.【F:wwwroot/js/soft-navigation.js†L228-L308】【F:wwwroot/js/soft-navigation.js†L1088-L1116】
- Глобальные индикаторы загрузки и `CustomEvent` `soft:pending-state` позволяют синхронизировать UI с состоянием сетевых запросов.【F:wwwroot/js/soft-navigation.js†L688-L748】

## Потенциальные узкие места
1. **Монолитность и скрытые зависимости**. Файл превышает тысячу строк, почти всё состояние (`app`, `appAnimationState`, `pendingState`, `scrollPositions`) хранится в одном замыкании. Любое изменение требует искать связи по всему модулю, что повышает риск регрессий и мешает переиспользованию утилит вроде `waitForTransition` в других частях проекта.【F:wwwroot/js/soft-navigation.js†L1-L320】【F:wwwroot/js/soft-navigation.js†L640-L728】
2. **Полный перерендер при каждом переходе**. `fetchAndSwap` парсит весь HTML через `DOMParser`, затем делает `importNode` и заменяет `#app` целиком. Даже при изменении небольшого блока мы повторно выполняем `querySelector` для `[data-soft-scroll-target]`, `#toastsHost`, `#pageScripts`, что увеличивает задержку и давление на GC на насыщенных страницах. Частичная дифф-замена или возвращение JSON/фрагментов были бы дешевле.【F:wwwroot/js/soft-navigation.js†L820-L1016】
3. **Принудительные reflow из-за анимаций**. `animateAppVisibility` и `createTransitionForSelector` многократно вызывают `getComputedStyle`, `offsetWidth`, `requestAnimationFrame` и меняют inline-стили. При нескольких селекторах это легко превращается в каскадные layout-циклы и визуальные рывки на слабых устройствах. Желательно перенести расчёты в CSS и минимизировать синхронный доступ к layout.【F:wwwroot/js/soft-navigation.js†L32-L112】【F:wwwroot/js/soft-navigation.js†L360-L456】
4. **Нестабильный менеджмент загрузок**. `buttonLoadingCounts` и `activeLoadingTargets` очистятся только если промис завершился успешно. При исключениях или смене страницы спасает лишь `resetAllLoadingStates`, который вызывается точечно (провал навигации, `popstate`). Это оставляет риск "залипших" кнопок и удержания DOM-узлов в памяти. Нужны тайм-ауты, `finally` и `WeakSet`/`WeakMap` для автоматического сброса.【F:wwwroot/js/soft-navigation.js†L512-L612】【F:wwwroot/js/soft-navigation.js†L960-L1020】
5. **Стоимость переходов растёт со сложностью селекторов**. Каждый вызов `createScopedTransition` парсит строку селекторов и пробегает `querySelector` по всему `app`. При повторяющихся переходах это лишние проходы по DOM. Кэширование разобранных селекторов или централизованный реестр переходов снизят накладные расходы.【F:wwwroot/js/soft-navigation.js†L320-L420】
6. **Ограниченная наблюдаемость ошибок**. Большинство `catch` веток логируют только при включённом `data-soft-debug`. В продакшене пользователь видит лишь полный редирект, а разработчики — пустой стек. Стоит централизовать `fallbackToHardNavigation` с обязательным `console.error`/отправкой в трекинг.【F:wwwroot/js/soft-navigation.js†L748-L880】
7. **Избыточные записи scroll state**. `storeScrollPosition` сериализует объект и пишет в `sessionStorage` при каждом переходе, даже если позиция не менялась или сторедж недоступен. Это добавляет синхронные операции во время навигации. Оптимальнее обновлять состояние лениво, после подтверждённого скролла, и пропускать запись при отсутствии `sessionStorage`.【F:wwwroot/js/soft-navigation.js†L400-L568】【F:wwwroot/js/soft-navigation.js†L996-L1040】

## Рекомендации по улучшению
1. **Разбить код на ES-модули**: вынести анимации, работу со скроллом, навигацию и индикаторы загрузки в отдельные файлы (`animations.js`, `transitions.js`, `navigation.js`, `loading.js`). Это сделает зависимости явными и упростит тестирование.
2. **Внедрить дифференциальные обновления**: рассмотреть переход на частичные ответы (JSON + шаблон, htmx, morphdom). Тогда `fetchAndSwap` будет обновлять только изменившиеся блоки и не придётся повторно выполнять `DOMParser` и `importNode` для всего `app`.
3. **Оптимизировать анимации**: описать ключевые состояния в CSS, использовать utility-классы вместо прямого управления `style`, а для `prefers-reduced-motion` — слушать `matchMedia().addEventListener('change', ...)` и мгновенно завершать анимации.
4. **Усилить менеджмент загрузок**: переводить `stopButtonLoading` в `finally` и дополнять тайм-аутом (например, 15 секунд) на случай зависших промисов. Хранить элементы в `WeakSet`, чтобы сборщик мусора очищал их после удаления из DOM, и эмитить `soft:loading-state` даже при аварийном сбросе.
5. **Кэшировать переходы**: хранить разобранные селекторы/transition-объекты в Map по ключу `data-soft-transition`. При замене `app` инвалидация кэша может выполняться централизованно, что сократит количество `querySelector`.
6. **Централизовать логирование**: создать helper, который всегда пишет в `console.error` и/или отправляет событие в Sentry при `fallbackToHardNavigation`. Флаг `data-soft-debug` можно использовать только для детализированных `console.debug` сообщений.
7. **Лениво сохранять scroll**: обновлять `sessionStorage` только при реальном изменении `scrollY` и наличии поддержки. Для восстановления после `popstate` использовать `requestAnimationFrame`, чтобы дождаться отрисовки и избежать рывков.
8. **Добавить профилирование и тесты**: использовать `performance.mark/measure` вокруг ключевых этапов (`fetch`, `transition.hide`, `DOMParser`) и покрыть критические утилиты (`buildGetUrl`, `shouldHandleLink`, `waitForTransition`) тестами в Jest + jsdom.

## Быстрые выигрыши
- Поставить флаг `window.__softNavInitialized` перед инициализацией (он уже есть) и логировать повторную попытку, чтобы избежать дублирования обработчиков.【F:wwwroot/js/soft-navigation.js†L2-L14】
- В `handleNavigation` сразу вызывать `resetAllLoadingStates` в `finally`, чтобы гарантированно разблокировать все кнопки при любых ошибках.
- Добавить `console.warn` при невозможности прочитать/записать scroll state, чтобы быстрее диагностировать проблемы с `sessionStorage`.
